// @subject: 
// @diff: 

#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;

#define st first
#define nd second
#define mp make_pair
#define pb push_back
#define cl(x, v) memset((x), (v), sizeof(x))
#define gcd(x,y) __gcd((x),(y))

#ifndef ONLINE_JUDGE
  #define db(x) cerr << #x << " == " << x << endl
  #define dbs(x) cerr << x << endl
  #define _ << ", " <<
#else
  #define db(x) ((void)0)
  #define dbs(x) ((void)0)
#endif

typedef long long ll;
typedef long double ld;

typedef pair<int, int> pii;
typedef pair<int, pii> piii;
typedef pair<ll, ll> pll;
typedef vector<int> vi;

const ld EPS = 1e-9, PI = acos(-1.);
const int INF = 0x3f3f3f3f, MOD = 1e9+7;
const int N = 1e3+5;

// Change long double to long long if using integers
typedef long long type;

bool ge(type x, type y) { return x + EPS > y; }
bool le(type x, type y) { return x - EPS < y; }
bool eq(type x, type y) { return ge(x, y) and le(x, y); }

struct point {
  type x, y;

  point() : x(0), y(0) {}
  point(type x, type y) : x(x), y(y) {}

  bool operator<(point p) const { return x == p.x ? y < p.y : x < p.x; }
  bool operator==(point p) const { return make_pair(x, y) == make_pair(p.x, p.y); }
  bool operator!=(point p) { return !(*this == p); }

  point operator -() { return point(-x, -y); }
  point operator +(point p) { return point(x+p.x, y+p.y); }
  point operator -(point p) { return point(x-p.x, y-p.y); }

  point operator *(type k) { return point(k*x, k*y); }
  point operator /(type k) { return point(x/k, y/k); }

  type operator *(point p) { return x*p.x + y*p.y; }
  type operator %(point p) { return x*p.y - y*p.x; }

  // o is the origin, p is another point
  // dir == +1 => p is clockwise from this
  // dir ==  0 => p is colinear with this
  // dir == -1 => p is counterclockwise from this
  int dir(point o, point p) {
    type x = (*this - o) % (p - o);
    return ge(x,0) - le(x,0);
  }

  bool on_seg(point p, point q) {
    if (this->dir(p, q)) return 0;
    return ge(x, min(p.x, q.x)) and le(x, max(p.x, q.x)) and
           ge(y, min(p.y, q.y)) and le(y, max(p.y, q.y));
  }

  ld abs() { return sqrt(x*x + y*y); }
  type abs2() { return x*x + y*y; }
  ld dist(point x) { return (*this - x).abs(); }
  type dist2(point x) { return (*this - x).abs2(); }

  ld arg() { return atan2l(y, x); }

  // Project point on vector y
  point project(point y) { return y * ((*this * y) / (y * y)); }

  // Project point on line generated by points x and y
  point project(point x, point y) { return x + (*this - x).project(y-x); }

  ld dist_line(point x, point y) { return dist(project(x, y)); }

  ld dist_seg(point x, point y) {
    return project(x, y).on_seg(x, y) ? dist_line(x, y) :  min(dist(x), dist(y));
  }

  point rotate(ld sin, ld cos) { return point(cos*x-sin*y, sin*x+cos*y); }
  point rotate(ld a) { return rotate(sin(a), cos(a)); }
  // rotate around the argument of vector p
  point rotate(point p) { return rotate(p.x / p.abs(), p.y / p.abs()); }
};


int direction(point o, point p, point q) { return p.dir(o, q); }

bool segments_intersect(point p, point q, point a, point b) {
  int d1, d2, d3, d4;
  d1 = direction(p, q, a);
  d2 = direction(p, q, b);
  d3 = direction(a, b, p);
  d4 = direction(a, b, q);
  if (d1*d2 < 0 and d3*d4 < 0) return 1;
  return p.on_seg(a, b) or q.on_seg(a, b) or
         a.on_seg(p, q) or b.on_seg(p, q);
}

point lines_intersect(point p, point q, point a, point b) {
  point r = q-p, s = b-a, c(p%q, a%b);
  if (eq(r%s,0)) return point(INF, INF);
  return point(point(r.x, s.x) % c, point(r.y, s.y) % c) / (r%s);
}

bool collinear(point p, point q, point a, point b) {
  point r = q-p, s = b-a;
  return eq(r%s,0);
}

typedef pair<point, point> pp;

int n, x, y, d;
vector<pp> ans;

vector<pp> get_sides() {
  vector<pp> ret;
  ret.push_back({ { x - d, y     }, { x    , y - d } });
  ret.push_back({ { x    , y - d }, { x + d, y     } });

  ret.push_back({ { x - d, y     }, { x    , y + d } });
  ret.push_back({ { x    , y + d }, { x + d, y     } });

  sort(ret.begin(), ret.end());
  ret.erase(unique(ret.begin(), ret.end()), ret.end());

  return ret;
}

pair<bool, pp> inter(pp a, pp b) {
  if (!collinear(a.st, a.nd, b.st, b.nd)) {
    if (segments_intersect(a.st, a.nd, b.st, b.nd)) {
      point p = lines_intersect(a.st, a.nd, b.st, b.nd);
      if (p.on_seg(a.st, a.nd) and p.on_seg(b.st, b.nd))
        return { true, { p, p } };
    }
    return { false, {} };
  }

  vector<point> ps;
  if (a.st.on_seg(b.st, b.nd)) ps.push_back(a.st);
  if (a.nd.on_seg(b.st, b.nd)) ps.push_back(a.nd);
  if (b.st.on_seg(a.st, a.nd)) ps.push_back(b.st);
  if (b.nd.on_seg(a.st, a.nd)) ps.push_back(b.nd);

  sort(ps.begin(), ps.end());
  ps.erase(unique(ps.begin(), ps.end()), ps.end());
  assert(ps.size() <= 2);

  if (ps.size() == 0) return { false, {} };
  if (ps.size() == 1) return { true, { ps[0], ps[0] } };
  return { true, { ps[0], ps[1] } };
}

void add() {
  vector<pp> g = get_sides();
  vector<pp> k;

  for (auto x : g) {
    for (auto y : ans) {
      auto z = inter(x, y);
      if (z.st)
        k.push_back(z.nd);
    }
  }

  sort(k.begin(), k.end());
  k.erase(unique(k.begin(), k.end()), k.end());

  ans = k;
}

int main() {
  scanf("%d", &n);

  scanf("%d%d%d", &x, &y, &d);
  ans = get_sides();

  for (int i = 1; i < n; i++) {
    scanf("%d%d%d", &x, &y, &d);
    add();
  }

  if (ans.size() == 0) return !printf("impossible\n");
  if (ans.size() >  1 or ans[0].st != ans[0].nd) return !printf("uncertain\n");
  printf("%lld %lld\n", ans[0].st.x, ans[0].st.y);

  return 0;
}
